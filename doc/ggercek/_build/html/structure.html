

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>System Structure &mdash; Ovizart-NG 0.1a documentation</title>
    
    <link rel="stylesheet" href="_static/default.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '',
        VERSION:     '0.1a',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <link rel="top" title="Ovizart-NG 0.1a documentation" href="index.html" />
    <link rel="next" title="REST API" href="rest_api.html" />
    <link rel="prev" title="Usage Examples" href="usage.html" /> 
  </head>
  <body>
<h1>Ovizart-NG Google Summer of Code 2013 / Honeynet Project</h1>
<!--
<div style="background-color: white; text-align: left; padding: 10px 10px 15px 15px">
<a href="index.html"><img src="_static/logo.png" border="0" alt="py4sci"/></a>
</div>
-->

    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="rest_api.html" title="REST API"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="usage.html" title="Usage Examples"
             accesskey="P">previous</a> |</li>
        <li><a href="index.html">home</a>|&nbsp;</li>
        <li><a href="search.html">search</a>|&nbsp;</li>
 
      </ul>
    </div>

      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
  <h3><a href="index.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">System Structure</a><ul>
<li><a class="reference internal" href="#overview">Overview</a><ul>
<li><a class="reference internal" href="#classes">Classes</a></li>
<li><a class="reference internal" href="#workflow">Workflow</a></li>
</ul>
</li>
<li><a class="reference internal" href="#modules">Modules</a><ul>
<li><a class="reference internal" href="#decorators">Decorators</a></li>
<li><a class="reference internal" href="#datasource">DataSource</a></li>
<li><a class="reference internal" href="#tagger">Tagger</a><ul>
<li><a class="reference internal" href="#application-layer-protocol-tagger">Application Layer Protocol Tagger</a></li>
</ul>
</li>
<li><a class="reference internal" href="#reassembler">Reassembler</a><ul>
<li><a class="reference internal" href="#problematic-case">Problematic case</a></li>
</ul>
</li>
<li><a class="reference internal" href="#analyzer">Analyzer</a></li>
<li><a class="reference internal" href="#reporter">Reporter</a></li>
</ul>
</li>
</ul>
</li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="usage.html"
                        title="previous chapter">Usage Examples</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="rest_api.html"
                        title="next chapter">REST API</a></p>
  <h3>This Page</h3>
  <ul class="this-page-menu">
    <li><a href="_sources/structure.txt"
           rel="nofollow">Show Source</a></li>
  </ul>
<div id="searchbox" style="display: none">
  <h3>Quick search</h3>
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <div class="section" id="system-structure">
<span id="structure"></span><h1>System Structure<a class="headerlink" href="#system-structure" title="Permalink to this headline">¶</a></h1>
<div class="section" id="overview">
<span id="id1"></span><h2>Overview<a class="headerlink" href="#overview" title="Permalink to this headline">¶</a></h2>
<p>This page will explain the basics of the projects design.</p>
<p>Before starting to explain the classes here is the UML of the design summary:</p>
<img alt="_images/ovizartng.png" src="_images/ovizartng.png" style="width: 1075px; height: 512px;" />
<div class="section" id="classes">
<h3>Classes<a class="headerlink" href="#classes" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li><strong>Data</strong>: Data class will contain 2 only dictionary, with names: data and tags. While the data dictionary holds the
basic data provided by data source(namely pcap files, hpfeeds data or netflow data), tags contains the meta-data or
information extracted/calculated by using/analyzing the data. From now on all information generated by system
components/modules will be named as tags.</li>
<li><strong>Analysis</strong>: This represents an analysis process. All the collected/calculated data will store is this class in
order to organize/store the data and provide history capability to ovizart. System may run multiple analysis&#8217;
parallel in async manner.</li>
<li><strong>Ovizart</strong>: This class provides an interface for the User Interfaces, which are defined as CLI and Web. This class
works as a mediator to organize the system calls and query the module availability, analysis state or update config
parameters as well.</li>
</ul>
</div>
<div class="section" id="workflow">
<h3>Workflow<a class="headerlink" href="#workflow" title="Permalink to this headline">¶</a></h3>
<p>The workflow of core system can be summarized like this;</p>
<ol class="arabic simple">
<li>Parse pcap, extract streams. Streams are packet groups based on 5 tuple(proto, srcIP, srcPort, dstIP, dstPort) where
port info applicable, otherwise we use 3 tuple to identify connections. Separate pcap files per stream are created
during this step. Also ip fragmentation is handled at this step.</li>
<li>Tag the separate traffic data. Each stream&#8217;s pcap file is parsed at this procedure to detect application layer protocol.
This module is currently depends on payload signatures. Supported protocols are: HTTP, HTTPS, SMTP, FTP, SSH, SOCKSv4.
Found application layer protocols are added to streams as tag elements.</li>
<li>After tagging with protocol information each flow processed by this module to extract application layer traffic in a
more analyze/user friendly format. Our system also support to add protocol specific reassemblers. Currently our system
support HTTP and SMTP, that means we are able to extract transferred files over these protocol. After this process 3
files generated for each stream. request.traffic, response.traffic, total.traffic. First 2 files contain unidirectional
traffic where the last one contain bidirectional traffic.</li>
<li>This step belongs to analyzer module. Based on the tag values, streams are analyzed by appropriate analyzers. For example
virus total analyzers support only binary file. Any stream has binary attachment will be processed by that particular
analyzer. During this process a stream maybe analyzed by more than one analyzer. After analyzers completed their job,
analyzers should tag the streams about the results.</li>
<li>For the last step reporter modules process and format the calculated or measured stream values.</li>
</ol>
</div>
</div>
<div class="section" id="modules">
<span id="id2"></span><h2>Modules<a class="headerlink" href="#modules" title="Permalink to this headline">¶</a></h2>
<p>Ovizart is basically composed of 5 modules; Data Source, Tagger, Reassembler, Analyzer and Reporter. Each module is
separated from each other in order to provide modularity. They will not communicate with each other directly. Each
module completes its job and add new tags to data they process. if necessary. System will forward processed data to
next module. So it is quite easy to add new modules or new classes to existing modules. Ovizart has a transparent
evaluation engine which will hide the integration details from developers by using decorators. Thanks to decorators
during start-up all decorated classes will be, first checked whether they are valid or not, then instantiated an object
and register it to system. All of the modules has its own decorators.</p>
<p>It would be nice to check the decorator structure before we move in other modules.</p>
<div class="section" id="decorators">
<span id="id3"></span><h3>Decorators<a class="headerlink" href="#decorators" title="Permalink to this headline">¶</a></h3>
<p>Rather than using inheritance we choose to use class decorators to provide extensibility. This approach is quite easy to use and hides the integration details. Here is an example for an awesome IRC analyzer;</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">ovizart</span> <span class="kn">import</span> <span class="n">Analyzer</span>
<span class="kn">from</span> <span class="nn">ovizart</span> <span class="kn">import</span> <span class="n">Tags</span>

<span class="c"># TODO: Revise this part. too long to use</span>
<span class="n">IRC</span> <span class="o">=</span> <span class="n">Tags</span><span class="o">.</span><span class="n">Protocol</span><span class="o">.</span><span class="n">IRC</span>

<span class="c"># For tags, one may use array as well, both of them accepted.</span>
<span class="nd">@Analyzer</span><span class="p">(</span><span class="n">tags</span><span class="o">=</span><span class="n">IRC</span><span class="p">)</span>
<span class="k">class</span> <span class="nc">MyAwesomeIRCAnalyzer</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Here is the awesome description of awesome irc analyzer...&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">print</span> <span class="s">&quot;I&#39;m awesome&quot;</span>

    <span class="k">def</span> <span class="nf">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s">&quot;MyAwesomeIRCAnalyzer&quot;</span>

    <span class="k">def</span> <span class="nf">analyze</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">):</span>
        <span class="c"># Do some awesome stuff here</span>
        <span class="k">pass</span>
</pre></div>
</div>
<p>Let&#8217;s examine the code,:</p>
<div class="highlight-python"><pre>@Analyzer(tags=IRC)</pre>
</div>
<p>The decorator expression registers MyAwesomeIRCAnalyzer to ovizart&#8217;s core system. One of the important detail is the tags parameter. This parameter may be a single value variable or an array as well. This parameter is used as a matching criteria. In this case any data with tag value IRC(which is a simple string) will be processed by this class&#8217;s analyze method.:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="sd">&quot;&quot;&quot;Here is the awesome description of awesome irc analyzer...&quot;&quot;&quot;</span>

<span class="k">def</span> <span class="nf">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
     <span class="k">return</span> <span class="s">&quot;MyAwesomeIRCAnalyzer&quot;</span>
</pre></div>
</div>
<p>class doc string or __doc__ variable and __repr__ method are important because these are used for description/name of the module and provide help info to end user.:</p>
<div class="highlight-python"><pre>def analyze(self, data)</pre>
</div>
<p>This is the analyzers main method, which must be exist! Analyzer decorator checks for this class and if it can not find then it will raise MissingMethodException. Also the method signature must be same otherwise it will raise MissingArgumentException</p>
<p>Each decorator makes this control for the following methods signatures;:</p>
<div class="highlight-python"><pre>DataSource =&gt; parse(self, filename, outputFolder)
Tagger =&gt; tag(self, data)
Reassembler =&gt; process(data)
Analyzer =&gt; analyze(self, data)
Reporter =&gt; report(self, data, outputPath)</pre>
</div>
</div>
<div class="section" id="datasource">
<span id="id4"></span><h3>DataSource<a class="headerlink" href="#datasource" title="Permalink to this headline">¶</a></h3>
<p>This module is responsible for handling of pcap files and extracting streams. A Stream can be defined as whole
traffic between 2 hosts. Streams are identified by proto, IP1, [port1], IP2, [port2]. port info will be used where
applicable. Also this module generates summary information about a pcap file. Splits the given pcap file based on
extracted streams.</p>
</div>
<div class="section" id="tagger">
<span id="id5"></span><h3>Tagger<a class="headerlink" href="#tagger" title="Permalink to this headline">¶</a></h3>
<p>This module is responsible for packet based attribute measurement and/or calculations. Currently we are supporting only
application layer protocol detection based on payload of captured packets. But it is also possible to add new taggers to
check file header signatures, shell code signatures and even detect whether the traffic is encrypted or not.</p>
<div class="section" id="application-layer-protocol-tagger">
<h4>Application Layer Protocol Tagger<a class="headerlink" href="#application-layer-protocol-tagger" title="Permalink to this headline">¶</a></h4>
<p>How I implemented protocol detection mechanism is quite simple. First of all I had to override of guess_payload_class
functions of both TCP and UDP layers, which was easy(from now on TCP and UDP classes in Scapy will be mentioned as
OldTCP and OldUDP). Then I needed to split OldTCP and OldUDP layers from IP layer so that we can use our TCP and UDP
classes. Here is the content of new TCP class’s guess_payload_class function;:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">guess_payload_class</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">payload</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">sig</span><span class="p">,</span> <span class="n">cls</span> <span class="ow">in</span> <span class="n">tcp_signatures</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">re</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">sig</span><span class="p">,</span> <span class="n">payload</span><span class="p">,</span> <span class="n">re</span><span class="o">.</span><span class="n">IGNORECASE</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">cls</span>
<span class="c"># if signatures are empty or signatures matched</span>
<span class="k">return</span> <span class="n">OldTCP</span><span class="o">.</span><span class="n">guess_payload_class</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">payload</span><span class="p">)</span>
</pre></div>
</div>
<p>where the tcp_signatures is a simple array of (signature, class) tuples;:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">tcp_signatures</span> <span class="o">=</span> <span class="p">[</span>
    <span class="p">(</span><span class="s">r&#39;^(EHLO|DATA|AUTH|MAIL|RCPT|QUIT).*&#39;</span><span class="p">,</span> <span class="n">SMTPRequest</span><span class="p">),</span>
    <span class="p">(</span><span class="s">r&#39;^(GET|HEAD|POST|OPTIONS|PUT|DELETE|TRACE|CONNECT).*&#39;</span><span class="p">,</span> <span class="n">HTTPRequest</span><span class="p">),</span>
    <span class="p">(</span><span class="s">r&#39;^(HTTP\/[0-9]).*&#39;</span><span class="p">,</span> <span class="n">HTTPResponse</span><span class="p">),</span>
    <span class="p">(</span><span class="s">r&#39;^(230|331).*&#39;</span><span class="p">,</span> <span class="n">FTPResponse</span><span class="p">)</span>
                <span class="p">]</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="reassembler">
<span id="id6"></span><h3>Reassembler<a class="headerlink" href="#reassembler" title="Permalink to this headline">¶</a></h3>
<p>After extracting streams from pcap files we need to examine the traffic. Although this could be done by inspecting each
packets which is what we are doing it on Tagger module for protocol detection reasons. But this approach is easy to
bypass using fragmentation. Another reason is to inspect the whole traffic in a higher level. This module is composed
of two layers; BaseReassembler and ProtocolReassembler.</p>
<p>First layer, BaseReassembler is responsible for running and interacting with justniffer. It will save the traffic into
3 files for further analysis. The files contains the reconstructed traffic between two hosts(A, B), with names of
‘request.traffic’(A-&gt;B), ‘response.traffic’(A&lt;-B) and ‘total.traffic’(AB). Here is the sample content of files from a
http connection.</p>
<p><strong>A -&gt; B, request.traffic</strong>:</p>
<div class="highlight-python"><pre>GET / HTTP/1.1
User-Agent: Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.0) Opera 7.11  [en]
Host: 10.1.1.1
Accept: application/x-shockwave-flash,text/xml,application/xml,application/xhtml+xml,text/html;q=0.9,text/plain;q=0.8,video/x-mng,image/png,image/jpeg,image/gif;q=0.2,text/css,*/*;q=0.1
Accept-Language: en
Accept-Charset: windows-1252, utf-8, utf-16, iso-8859-1;q=0.6, *;q=0.1
Accept-Encoding: deflate, gzip, x-gzip, identity, *;q=0
Connection: Keep-Alive</pre>
</div>
<p><strong>A &lt;- B, response.traffic</strong>:</p>
<div class="highlight-python"><pre>HTTP/1.1 200 OK
Date: Sat, 20 Nov 2004 10:21:06 GMT
Server: Apache/2.0.40 (Red Hat Linux)
Last-Modified: Mon, 08 Mar 2004 20:27:54 GMT
ETag: "46eed-a0-800ce680"
Accept-Ranges: bytes
Content-Length: 160
Connection: close
Content-Type: text/html; charset=ISO-8859-1

&lt;html&gt;
&lt;head&gt;
&lt;title&gt;
Ronnie sahlbergs Websida
&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;a href="./Websidan/index.html"&gt;Familjen Sahlbergs Websida&lt;/a&gt;
&lt;/body&gt;
&lt;/html&gt;</pre>
</div>
<p><strong>A &lt;-&gt; B, total.traffic:</strong>:</p>
<div class="highlight-python"><pre>GET / HTTP/1.1
User-Agent: Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.0) Opera 7.11  [en]
Host: 10.1.1.1
Accept: application/x-shockwave-flash,text/xml,application/xml,application/xhtml+xml,text/html;q=0.9,text/plain;q=0.8,video/x-mng,image/png,image/jpeg,image/gif;q=0.2,text/css,*/*;q=0.1
Accept-Language: en
Accept-Charset: windows-1252, utf-8, utf-16, iso-8859-1;q=0.6, *;q=0.1
Accept-Encoding: deflate, gzip, x-gzip, identity, *;q=0
Connection: Keep-Alive

HTTP/1.1 200 OK
Date: Sat, 20 Nov 2004 10:21:06 GMT
Server: Apache/2.0.40 (Red Hat Linux)
Last-Modified: Mon, 08 Mar 2004 20:27:54 GMT
ETag: "46eed-a0-800ce680"
Accept-Ranges: bytes
Content-Length: 160
Connection: close
Content-Type: text/html; charset=ISO-8859-1

&lt;html&gt;
&lt;head&gt;
&lt;title&gt;
Ronnie sahlbergs Websida
&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;a href="./Websidan/index.html"&gt;Familjen Sahlbergs Websida&lt;/a&gt;
&lt;/body&gt;
&lt;/html&gt;</pre>
</div>
<p>The second layer is ProtocolReassembler. This layer is responsible for extracting application layer info or useful data such as transferred files, email body, etc. In our system there are two kinds of ProtocolReassembler exists, HTTP and SMTP and our tool is able to extract files in HTTP and SMTP streams such as html, js, etc. and save under the attachments folder of related stream.</p>
<div class="section" id="problematic-case">
<h4>Problematic case<a class="headerlink" href="#problematic-case" title="Permalink to this headline">¶</a></h4>
<p><a class="reference external" href="http://web.archive.org/liveweb/http://seclists.org/snort/2012/q4/396">http://web.archive.org/liveweb/http://seclists.org/snort/2012/q4/396</a></p>
<div class="highlight-python"><pre>Example: A TCP stream flows between client and server just fine (e.g. a long http/1.1 keep-alive session).
Some random packets are dropped in the mirrored copies. When libnids sniff this and reassemble the stream,
I want it to leave a gap in the buffer where there are missing packets, and continue processing the flow.
Currently it stops processing the flow.</pre>
</div>
</div>
</div>
<div class="section" id="analyzer">
<span id="id7"></span><h3>Analyzer<a class="headerlink" href="#analyzer" title="Permalink to this headline">¶</a></h3>
<p>Please check the documentation of Hao MA</p>
</div>
<div class="section" id="reporter">
<span id="id8"></span><h3>Reporter<a class="headerlink" href="#reporter" title="Permalink to this headline">¶</a></h3>
<p>Please check the documentation of Hao MA</p>
</div>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="rest_api.html" title="REST API"
             >next</a> |</li>
        <li class="right" >
          <a href="usage.html" title="Usage Examples"
             >previous</a> |</li>
        <li><a href="index.html">home</a>|&nbsp;</li>
        <li><a href="search.html">search</a>|&nbsp;</li>
 
      </ul>
    </div>
    <div class="footer">
        &copy; Copyright 2013, Gurcan GERCEK.
      Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.1.3.
    </div>
  </body>
</html>